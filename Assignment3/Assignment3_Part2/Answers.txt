1. What is the purpose of the function spawn?


2. What is the purpose of the function dispatch?


3. What is the purpose of the function yield?
• enqueue the current thread at the ready queue
• pick a new thread from the ready queue
• update current
• perform the setjmp(A); longjmp(B) trick to switch contexts – a dispatch


4. After finishing the execution of line 3, describe the content of readyQ.


5. After finishing the execution of line 3, describe the content of freeQ.


6. Consider the code above and the a3p1.img kernel from Pat 1. Which task executes first? Why?


7. As they are, functions computePower and computePrimes execute indefinitely, i.e, never return.
However, and considering the a3p1.img kernel, these functions are executed concurrently. How?


8. Again, computePower and computePrimes never return. However, consider a situation when these functions return.
This implies that the tiny thread assigned to execute the task will terminate.
Consequently, if you want or need to execute a task again, you might need to track which tiny threads terminated.
One approach is to keep information about the terminated threads in a list called doneQ. Thus, where in lib/tinythreads.c, would add the tiny thread that terminated into doneQ?
