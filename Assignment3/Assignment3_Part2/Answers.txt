1. What is the purpose of the function spawn?
    Creates a thread block and make sure it's initiated, gives it a start routine.

2. What is the purpose of the function dispatch?
    As the name suggests it dispatches the given thread.
    First it check if it is null or empty then uses longjmp to finnish off the thread.

3. What is the purpose of the function yield?
    Enqueues the current thread from the ready queue, updates current.
    Does the context switching/dispatch.

4. After finishing the execution of line 3, describe the content of readyQ.
    newp = newThread
    readyQ[] = {newThread};

    newThread{
    fun = computePower
    arg = 0
    context =
    }

5. After finishing the execution of line 3, describe the content of freeQ.
    There are four free spots left in the freeQ since one have been moved from freeQ to readyQ.
    By looking at NTHREADS defined in tinythreads.c we can see there are total of 5 spots/threads.


6. Consider the code above and the a3p1.img kernel from Pat 1. Which task executes first? Why?
    ComputePower, because spawn does move the thread into the readyQ.
    But the first task that will be executed is the ComputePower.

7. As they are, functions computePower and computePrimes execute indefinitely, i.e, never return.
However, and considering the a3p1.img kernel, these functions are executed concurrently. How?
    Because of the function of yield();

8. Again, computePower and computePrimes never return. However, consider a situation when these functions return.
This implies that the tiny thread assigned to execute the task will terminate.
Consequently, if you want or need to execute a task again, you might need to track which tiny threads terminated.
One approach is to keep information about the terminated threads in a list called doneQ. Thus, where in lib/tinythreads.c, would add the tiny thread that terminated into doneQ?
    Should be done in the function yield();